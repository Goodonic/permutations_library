/**
 * ЗАДАЧА 3.3: Алгоритм порядка минимальных изменений (Gray code)
 * 1. Каждая следующая перестановка отличается одной транспозицией
 * 2. Транспозиция всегда соседних элементов
 * 3. Реализация через алгоритм Эрлиха
 * 4. Оптимизация для кэширования
 */
void permutations_minimal_change(int arr[], int n, void (*callback)(int perm[], int n))
{
    // Инициализация массивов a, b, c (алгоритм Эрлиха)
    // Вызов callback() для начальной перестановки
    // Основной цикл алгоритма:
    //   k = 1
    //   while k < n:
    //     обмен arr[b[k]] и arr[b[k] + c[k]]
    //     callback(arr, n)
    //     обновление b[k] и c[k]
    //   k = 1
    // Гарантировать свойство минимального изменения
}